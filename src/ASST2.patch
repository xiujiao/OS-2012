diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..86ff958
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,11 @@
+build
+.depend
+/defs.mk
+kern/compile/
+*.o
+*.swp
+*~
+*#
+tags
+typescript
+user/testbin/randcall/calls.c
diff --git a/kern/arch/mips/locore/trap.c b/kern/arch/mips/locore/trap.c
index ff39633..6e963c1 100644
--- a/kern/arch/mips/locore/trap.c
+++ b/kern/arch/mips/locore/trap.c
@@ -256,6 +256,7 @@ mips_trap(struct trapframe *tf)
 		 * The MIPS won't even tell you what invalid address
 		 * caused the bus error.
 		 */
+		DEBUG(DB_SYSCALL, "invalid TLB entries were loaded\n");
 		panic("Bus error exception, PC=0x%x\n", tf->tf_epc);
 		break;
 	}
diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
index 0f773bd..7c154b6 100644
--- a/kern/arch/mips/syscall/syscall.c
+++ b/kern/arch/mips/syscall/syscall.c
@@ -35,7 +35,8 @@
 #include <thread.h>
 #include <current.h>
 #include <syscall.h>
-
+#include <process.h>
+#include <copyinout.h>
 
 /*
  * System call dispatcher.
@@ -80,7 +81,12 @@ syscall(struct trapframe *tf)
 {
 	int callno;
 	int32_t retval;
-	int err;
+	int err; 
+
+	int code;
+	off_t offset1 = 0;
+	off_t offset2 = 0;
+	off_t offset = 0;
 
 	KASSERT(curthread != NULL);
 	KASSERT(curthread->t_curspl == 0);
@@ -100,21 +106,69 @@ syscall(struct trapframe *tf)
 	retval = 0;
 
 	switch (callno) {
-	    case SYS_reboot:
-		err = sys_reboot(tf->tf_a0);
-		break;
-
-	    case SYS___time:
-		err = sys___time((userptr_t)tf->tf_a0,
-				 (userptr_t)tf->tf_a1);
-		break;
-
-	    /* Add stuff here */
- 
-	    default:
-		kprintf("Unknown syscall %d\n", callno);
-		err = ENOSYS;
-		break;
+		//process system calls
+		case SYS_fork:
+			err = sys_fork(tf, &retval);	
+			break;
+		case SYS_execv:
+			err = sys_execv((const char *)tf->tf_a0, (char *const *)tf->tf_a1);
+			break;
+		case SYS__exit:
+			err = sys_exit(tf->tf_a0);
+			break;
+		case SYS_waitpid:
+			err = sys_waitpid(tf->tf_a0, (int *)tf->tf_a1, tf->tf_a2, &retval);
+			break;
+		case SYS_getpid:
+			err = sys_getpid(&retval);
+			break;
+
+		//file system calls
+		case SYS_open:
+			err = sys_open((const char *)tf->tf_a0, tf->tf_a1, tf->tf_a2, &retval);
+			break;
+		case SYS_close:
+			err = sys_close(tf->tf_a0);
+			break;
+		case SYS_read:
+			err = sys_read(tf->tf_a0, (void *)tf->tf_a1, tf->tf_a2, &retval);
+			break;
+		case SYS_write:
+			err = sys_write(tf->tf_a0, (const void *)tf->tf_a1, tf->tf_a2, &retval );
+			break;		
+		case SYS_lseek:
+			{
+				err=copyin((const_userptr_t)tf->tf_sp+16, &code, sizeof(int));
+				if(err){
+					break;
+				}
+				offset1=tf->tf_a2;
+				offset2=tf->tf_a3;
+			   offset=offset1<<32;
+			   offset+=offset2;
+				err = sys_lseek(tf->tf_a0, offset ,code, &retval,&(tf->tf_v1));
+				break;
+			}
+		case SYS_dup2:
+			err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+			break;
+		case SYS_chdir:
+			err = sys_chdir(( char *)tf->tf_a0);
+			break;
+		case SYS___getcwd:
+			err = sys_getcwd((char *) tf->tf_a0, tf->tf_a1, &retval);
+			break;
+
+		case SYS_reboot:
+			err = sys_reboot(tf->tf_a0);
+			break;
+		case SYS___time:
+			err = sys___time((userptr_t)tf->tf_a0, (userptr_t)tf->tf_a1);
+			break;
+		default:
+			kprintf("Unknown syscall %d\n", callno);
+			err = ENOSYS;
+			break;
 	}
 
 
@@ -155,7 +209,21 @@ syscall(struct trapframe *tf)
  * Thus, you can trash it and do things another way if you prefer.
  */
 void
-enter_forked_process(struct trapframe *tf)
+enter_forked_process(struct trapframe *tf, struct addrspace *addr)
 {
-	(void)tf;
+	struct trapframe child_tf;
+
+	memmove(&child_tf, tf, sizeof(struct trapframe));
+
+	//curthread->t_addrspace = addr;
+	as_copy(addr, &curthread->t_addrspace);
+	as_activate(curthread->t_addrspace);
+
+	kfree(tf);
+	kfree(addr);
+
+	child_tf.tf_v0 = 0;
+	child_tf.tf_epc += 4;
+	child_tf.tf_a3 = 0;
+	mips_usermode(&child_tf);
 }
diff --git a/kern/arch/mips/vm/dumbvm.c b/kern/arch/mips/vm/dumbvm.c
index ca9992a..3e17ba1 100644
--- a/kern/arch/mips/vm/dumbvm.c
+++ b/kern/arch/mips/vm/dumbvm.c
@@ -138,6 +138,7 @@ vm_fault(int faulttype, vaddr_t faultaddress)
 		 * fault early in boot. Return EFAULT so as to panic
 		 * instead of getting into an infinite faulting loop.
 		 */
+		DEBUG(DB_VM, "No address space set up. This is probably a kernel fault early in boot.");
 		return EFAULT;
 	}
 
diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
index d527f61..f0404a0 100644
--- a/kern/conf/conf.kern
+++ b/kern/conf/conf.kern
@@ -314,6 +314,18 @@ file      ../common/libc/string/strtok_r.c
 ########################################
 
 #
+# Process System Calls
+#
+
+file      syscall/process.c
+
+#
+# File System System Calls
+#
+
+file      syscall/sys_file.c
+
+#
 # Thread system
 #
 
diff --git a/kern/include/process.h b/kern/include/process.h
new file mode 100644
index 0000000..7b8c7de
--- /dev/null
+++ b/kern/include/process.h
@@ -0,0 +1,85 @@
+#ifndef _PROCESS_H_
+#define _PROCESS_H_
+
+#include <types.h>
+#include <limits.h>
+#include <kern/errno.h>
+#include <kern/fcntl.h>
+#include <lib.h>
+#include <thread.h>
+#include <current.h>
+#include <addrspace.h>
+#include <vm.h>
+#include <vfs.h>
+#include <syscall.h>
+#include <test.h>
+#include <synch.h>
+#include <mips/trapframe.h>
+#include <copyinout.h>
+#include <kern/wait.h>
+
+//max process id entries look at kern/include/kern/limits.h - PID_MAX
+
+//global process ids counter
+volatile int process_id_count;
+
+//PID_MAX is from kern/include/limits.h
+volatile bool pid_in_use[PID_MAX];
+
+//struct for keeping process meta data
+struct meta_process{
+	int p_pid;
+	struct cv* exit_cv;
+	struct lock* exit_lk;
+	bool exited;
+	int exitcode;
+};
+// global information for all the process
+struct meta_process all_process_meta[PID_MAX];
+
+//lock needed for create_process_id();
+struct lock *process_id_lk;
+
+//TODO syncro
+typedef struct {
+	struct lock *fldesc_lk;
+	int file_access;
+	volatile off_t offset;
+	volatile	int ref_count;
+	struct vnode *file_object;
+} file_desc;
+
+struct process {
+	//process id. just a typedef-ed int
+	//pid_t pid;
+	int pid;
+
+	//file table - implemented as an array with a counter
+   file_desc *file_table[OPEN_MAX];
+	//file table counter
+	int ft_counter;
+	
+	//we need some sort of locks?
+	//if we get to the scheduler
+	//priority
+};
+
+struct new_p_data {
+	struct trapframe *tf;
+	struct addrspace *addr;
+};
+
+//returns a process id that is not currently used
+//works off our global process variables
+int create_process_id(void);
+void process_init(void);
+int get_file_handle(struct process *p);
+void childs_waiting_area(void *params, unsigned long num);
+
+int sys_getpid(int32_t *retval);
+int sys_fork(struct trapframe *tf, int32_t *retval);
+int sys_execv(const char * program, char *const *args);
+int sys_waitpid(int pid, int * status, int options, int32_t *retval);
+int sys_exit(int exitcode);
+
+#endif
diff --git a/kern/include/synch.h b/kern/include/synch.h
index ac3714b..4614a99 100644
--- a/kern/include/synch.h
+++ b/kern/include/synch.h
@@ -73,7 +73,10 @@ void V(struct semaphore *);
  * (should be) made internally.
  */
 struct lock {
-        char *lk_name;
+		  char *lk_name;
+		  struct wchan *lk_wchan;
+		  struct spinlock lk_lock;
+		  volatile struct thread *lk_holder; 
         // add what you need here
         // (don't forget to mark things volatile as needed)
 };
@@ -113,6 +116,9 @@ void lock_destroy(struct lock *);
 
 struct cv {
         char *cv_name;
+		  struct wchan *cv_wchan;
+		  struct spinlock cv_lock;
+
         // add what you need here
         // (don't forget to mark things volatile as needed)
 };
@@ -143,14 +149,20 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
 
 struct rwlock {
         char *rwlock_name;
+		  struct semaphore *writing;
+		  struct semaphore *reading;
+		  
+		  struct semaphore *reader_count;
+		  
+		  volatile int reader_counter;
 };
 
-struct rwlock * rwlock_create(const char *);
+struct rwlock * rwlock_create(const char *name);
 void rwlock_destroy(struct rwlock *);
 
-void rwlock_acquire_read(struct rwlock *);
-void rwlock_release_read(struct rwlock *);
-void rwlock_acquire_write(struct rwlock *);
-void rwlock_release_write(struct rwlock *);
+void rwlock_acquire_read(struct rwlock *rw);
+void rwlock_release_read(struct rwlock *rw);
+void rwlock_acquire_write(struct rwlock *rw);
+void rwlock_release_write(struct rwlock *rw);
 
 #endif /* _SYNCH_H_ */
diff --git a/kern/include/syscall.h b/kern/include/syscall.h
index befd3d8..da95c7d 100644
--- a/kern/include/syscall.h
+++ b/kern/include/syscall.h
@@ -27,6 +27,8 @@
  * SUCH DAMAGE.
  */
 
+#include <addrspace.h>
+
 #ifndef _SYSCALL_H_
 #define _SYSCALL_H_
 
@@ -44,7 +46,8 @@ void syscall(struct trapframe *tf);
  */
 
 /* Helper for fork(). You write this. */
-void enter_forked_process(struct trapframe *tf);
+void enter_forked_process(struct trapframe *tf, struct addrspace *addr);
+//void enter_forked_process(struct trapframe *tf);
 
 /* Enter user mode. Does not return. */
 void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
@@ -58,4 +61,14 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
 int sys_reboot(int code);
 int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
 
+int sys_open(const char *filename, int flags, size_t mode, int32_t* retval);
+int sys_read(int filehandle, void *buf, size_t size, int32_t* retval);
+int sys_write(int filehandle, const void *buf, size_t size, int32_t* retval);
+int sys_close(int filehandle);
+int sys_dup2(int filehandle, int newhandle, int32_t* retval);
+int sys_chdir(char *path);
+off_t sys_lseek(int filehandle, off_t pos, int code, int32_t* retval, uint32_t* tfv1); 
+int sys_getcwd(char *buf, size_t buflen, int32_t * retval);
+
 #endif /* _SYSCALL_H_ */
+
diff --git a/kern/include/thread.h b/kern/include/thread.h
index 86706ca..0ababdb 100644
--- a/kern/include/thread.h
+++ b/kern/include/thread.h
@@ -38,6 +38,7 @@
 
 #include <spinlock.h>
 #include <threadlist.h>
+#include <process.h>
 
 struct addrspace;
 struct cpu;
@@ -46,6 +47,8 @@ struct vnode;
 /* get machine-dependent defs */
 #include <machine/thread.h>
 
+#define RESET_PRIORITY_PRIOD 32
+#define PRIORITY_SIZE 3 
 
 /* Size of kernel stacks; must be power of 2 */
 #define STACK_SIZE 4096
@@ -100,7 +103,6 @@ struct thread {
 	bool t_in_interrupt;		/* Are we in an interrupt? */
 	int t_curspl;			/* Current spl*() state */
 	int t_iplhigh_count;		/* # of times IPL has been raised */
-
 	/*
 	 * Public fields
 	 */
@@ -111,6 +113,11 @@ struct thread {
 	/* VFS */
 	struct vnode *t_cwd;		/* current working directory */
 
+	//Add staff here
+	struct process *process;
+
+	int priority_level;
+	
 	/* add more here as needed */
 };
 
diff --git a/kern/include/uio.h b/kern/include/uio.h
index 5d97c48..a2c34bf 100644
--- a/kern/include/uio.h
+++ b/kern/include/uio.h
@@ -52,6 +52,7 @@ enum uio_seg {
         UIO_SYSSPACE,			/* Kernel. */
 };
 
+//this is used to describe a data region
 struct uio {
 	struct iovec     *uio_iov;	/* Data blocks */
 	unsigned          uio_iovcnt;	/* Number of iovecs */
diff --git a/kern/lib/uio.c b/kern/lib/uio.c
index 594fe96..823f728 100644
--- a/kern/lib/uio.c
+++ b/kern/lib/uio.c
@@ -48,6 +48,7 @@ uiomove(void *ptr, size_t n, struct uio *uio)
 	if (uio->uio_rw != UIO_READ && uio->uio_rw != UIO_WRITE) {
 		panic("uiomove: Invalid uio_rw %d\n", (int) uio->uio_rw);
 	}
+	//if we are using 
 	if (uio->uio_segflg==UIO_SYSSPACE) {
 		KASSERT(uio->uio_space == NULL);
 	}
diff --git a/kern/startup/main.c b/kern/startup/main.c
index be4c4b8..1c595a9 100644
--- a/kern/startup/main.c
+++ b/kern/startup/main.c
@@ -1,3 +1,4 @@
+//My first comment
 /*
  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
  *	The President and Fellows of Harvard College.
@@ -100,13 +101,13 @@ boot(void)
 	kprintf("%s", harvard_copyright);
 	kprintf("\n");
 
-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
+	kprintf("jl353 and xiujiaog's system version %s (%s #%d)\n", 
 		GROUP_VERSION, buildconfig, buildversion);
 	kprintf("\n");
 
 	/* Early initialization. */
 	ram_bootstrap();
-	thread_bootstrap();
+	thread_bootstrap(); 
 	hardclock_bootstrap();
 	vfs_bootstrap();
 
diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
index 81d2f0e..93ff151 100644
--- a/kern/synchprobs/problems.c
+++ b/kern/synchprobs/problems.c
@@ -47,15 +47,49 @@
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
 
+//WHALE STUFF
+static struct semaphore *maleWhale1;
+static struct semaphore *maleWhale2;
+
+static struct semaphore *femaleWhale1;
+static struct semaphore *femaleWhale2;
+
+static struct semaphore *matchmakerMale;
+static struct semaphore *matchmakerFemale;
+
+//STOP LIGHT STUFF
+static struct lock *intersectionLock;
+static struct lock *quadLock[4];
+
+volatile bool quadLocked[4];
+
 void whalemating_init() {
-  return;
+
+	maleWhale1 = sem_create("maleWhale1", 1);
+	maleWhale2 = sem_create("maleWhale2", 1);
+
+	femaleWhale1 = sem_create("femaleWhale1", 1);
+	femaleWhale2 = sem_create("femaleWhale2", 1);
+
+	matchmakerMale = sem_create("matchmakerMale", 1);
+	matchmakerFemale = sem_create("matchmakerFemale", 1);
+
+	return;
 }
 
 // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void whalemating_cleanup() {
-  return;
+  
+	sem_destroy(maleWhale1);
+	sem_destroy(maleWhale2);
+	sem_destroy(femaleWhale1);
+	sem_destroy(femaleWhale2);
+	sem_destroy(matchmakerMale);
+	sem_destroy(matchmakerFemale);
+
+	return;
 }
 
 void
@@ -64,9 +98,14 @@ male(void *p, unsigned long which)
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
   (void)which;
   
-  male_start();
-	// Implement this function 
-  male_end();
+	male_start();
+
+	V(femaleWhale1);
+	P(maleWhale1);
+	P(maleWhale2);
+	V(matchmakerMale);
+
+  	male_end();
 
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
@@ -80,9 +119,14 @@ female(void *p, unsigned long which)
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
   (void)which;
   
-  female_start();
-	// Implement this function 
-  female_end();
+ 	female_start();
+
+	V(maleWhale1);
+	P(femaleWhale1);
+	P(femaleWhale2);
+	V(matchmakerFemale);
+ 	
+	female_end();
   
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
@@ -95,10 +139,15 @@ matchmaker(void *p, unsigned long which)
 {
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
   (void)which;
-  
-  matchmaker_start();
-	// Implement this function 
-  matchmaker_end();
+ 	
+	matchmaker_start();
+
+	V(maleWhale2);
+	V(femaleWhale2);
+	P(matchmakerMale);
+	P(matchmakerFemale);
+
+	matchmaker_end();
   
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
@@ -137,14 +186,35 @@ matchmaker(void *p, unsigned long which)
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
 
+
 void stoplight_init() {
-  return;
+  
+	intersectionLock = lock_create("intersectionLock");
+	
+	quadLock[0] = lock_create("quadLock0");
+	quadLock[1] = lock_create("quadLock1");
+	quadLock[2] = lock_create("quadLock2");
+	quadLock[3] = lock_create("quadLock3");
+ 
+	quadLocked[0] = false;
+	quadLocked[1] = false;
+	quadLocked[2] = false;
+	quadLocked[3] = false;
+
+  	return;
 }
 
 // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void stoplight_cleanup() {
+  
+  lock_destroy(intersectionLock);
+  lock_destroy(quadLock[0]);
+  lock_destroy(quadLock[1]);
+  lock_destroy(quadLock[2]);
+  lock_destroy(quadLock[3]);
+
   return;
 }
 
@@ -152,8 +222,38 @@ void
 gostraight(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
-  
+ 	
+	//this simulates cars lining up
+	lock_acquire(quadLock[direction]);
+	
+	int spot2 = (direction + 3) % 4;
+	bool throughIntersection = false;
+
+	//loop until the 2 quadrants that we need are open
+	while(!throughIntersection) {
+		lock_acquire(intersectionLock);
+		if(quadLocked[direction] == false && quadLocked[spot2] == false) {
+			quadLocked[direction] = true;
+			quadLocked[spot2] = true;
+			throughIntersection = true;
+		}
+			
+		lock_release(intersectionLock);
+	}
+	
+	//move through intersection and let everyone know out location
+	inQuadrant(direction);
+	inQuadrant(spot2);
+	leaveIntersection();
+
+	//let everyone know we have left the 2 quadrants we traveled through
+	lock_acquire(intersectionLock);
+	quadLocked[direction] = false;
+	quadLocked[spot2] = false;
+	lock_release(intersectionLock);
+ 
+	lock_release(quadLock[direction]);
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
@@ -164,7 +264,41 @@ void
 turnleft(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
+
+	//this simulates cars lining up
+	lock_acquire(quadLock[direction]);
+
+	int spot2 = (direction + 3) % 4;
+	int spot3 = (direction + 2) % 4;
+	bool throughIntersection = false;
+	
+	//loop until the 3 quadrants that we need are open
+	while(!throughIntersection) {
+		lock_acquire(intersectionLock);
+		if(quadLocked[direction] == false && quadLocked[spot2] == false && quadLocked[spot3] == false) {
+			quadLocked[direction] = true;
+			quadLocked[spot2] = true;
+			quadLocked[spot3] = true;
+			throughIntersection = true;
+		}
+			
+		lock_release(intersectionLock);
+	}
+	
+	//move through intersection and let everyone know out location
+	inQuadrant(direction);
+	inQuadrant(spot2);
+	inQuadrant(spot3);
+	leaveIntersection();
+	
+	//let everyone know we have left the 3 quadrants we traveled through
+	lock_acquire(intersectionLock);
+		quadLocked[direction] = false;
+		quadLocked[spot2] = false;
+		quadLocked[spot3] = false;
+	lock_release(intersectionLock);
+
+	lock_release(quadLock[direction]);
   
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
@@ -176,8 +310,34 @@ void
 turnright(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
 
+	//this simulates cars lining up
+	lock_acquire(quadLock[direction]);
+	
+	bool throughIntersection = false;
+
+	//loop until the 1 quadrants that we need are open
+	while(!throughIntersection) {
+		lock_acquire(intersectionLock);
+		if(quadLocked[direction] == false) {
+			quadLocked[direction] = true;
+			throughIntersection = true;
+		}
+			
+		lock_release(intersectionLock);
+	}
+
+	//move through intersection and let everyone know out location
+	inQuadrant(direction);
+	leaveIntersection();
+	
+	//let everyone know we have left the 1 quadrant we traveled throught
+	lock_acquire(intersectionLock);
+		quadLocked[direction] = false;
+	lock_release(intersectionLock);
+
+	lock_release(quadLock[direction]);
+  
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
diff --git a/kern/syscall/process.c b/kern/syscall/process.c
new file mode 100644
index 0000000..c65cdbc
--- /dev/null
+++ b/kern/syscall/process.c
@@ -0,0 +1,493 @@
+#include <process.h>
+
+//TODO right now I am setting process_id_count to 0 in thread_bootstrap();
+//TODO clean up process.h I might #include extra header files that I do not need
+//sys_fork() might be called since the result in tf->tf_v0 is the result from a previous syscall aka return 0; SYS_fork is 0;
+//look at array.c maybe we can use this type of array for our table? maybe we don't need to
+
+//call once during thread boot strap
+void process_init() {
+
+	//use PID_MIN from limits.h 
+	//process_id_count = PID_MIN;
+	process_id_count = PID_MIN;
+	process_id_lk = lock_create("process_id_array");
+	curthread->process->pid = 1;
+	//init LL
+	//
+}
+
+//uses a very similiar approach to get_file_handle
+int create_process_id() {
+
+	//use PID_MIN from limits.h
+	int itr = PID_MIN;
+	int return_id = 0;
+	bool used_old_id = false;
+
+	//iterate using process_id_count as a limit
+	//TODO we need to lock_acquire use this better. only surround necessary parts
+	lock_acquire(process_id_lk);	
+	while(itr < process_id_count) {
+		if(pid_in_use[itr] == false) {
+			return_id = itr;
+			
+			pid_in_use[itr] = true;
+			
+			used_old_id = true;
+			break;
+		}
+		itr++;
+	}
+	//if we have reached process_id_count in our loop we need to increase the process_id_counter
+	if(!used_old_id) {
+		pid_in_use[process_id_count] = true;
+		return_id = process_id_count;
+		process_id_count++;
+	}
+	//TODO we need to lock_release
+	lock_release(process_id_lk);
+	return return_id;
+}
+
+void childs_waiting_area(void *params, unsigned long num) {
+	(void) num;
+	struct new_p_data *par = (struct new_p_data *)params;
+	//enter_forked_process((struct trapframe *)params[0], (struct addrspace *)params[1], (int *)params[2]);
+	enter_forked_process(par->tf, par->addr);
+}
+//get file handle id's
+int get_file_handle(struct process *p) {
+
+	// 0,1,2 are used by standin/standout/err
+	int itr = 3;
+	int return_id = 0;
+	bool used_old_id = false;
+
+	//iterate using ft_counter
+	//TODO if we have multiple threads we need to lock_acquire
+	while(itr < p->ft_counter) {
+		if(p->file_table[itr] == NULL) {
+			return_id = itr;
+			used_old_id = true;
+			break;
+		}
+		itr++;
+	}
+	if(!used_old_id) {
+		return_id = p->ft_counter;
+		p->ft_counter++;
+	}
+	//TODO if we have multiple threads we need to lock_release
+	return return_id;
+}
+
+int sys_getpid(int32_t *retval) {
+	*retval = (int32_t)curthread->process->pid;
+	return 0;
+}
+
+// parent should keep a list of child process?
+// on fail be sure to free resouces (aka locks, any data on heap, open files, etc etc)
+// keep exit code from child process
+int sys_fork(struct trapframe *tf, int32_t *retval) {
+    
+	lock_acquire(process_id_lk);
+		
+	//check if null && check if to many pid count is larger then PID_MAX
+	int itr = 0;
+	if(process_id_count > PID_MAX) {
+		while(itr < process_id_count) {
+			if(pid_in_use[itr] == false) {
+				break;
+			}
+			itr++;
+		}
+		if(itr >= process_id_count) {
+			return EMPROC;
+		}
+	}
+	lock_release(process_id_lk);
+
+	 struct thread *newThread;
+	 struct trapframe *child_tf;
+	 struct addrspace *child_addr;
+	 struct new_p_data *child_param; 
+	 child_param = (struct new_p_data *)kmalloc(sizeof(struct new_p_data));
+
+	 //tf->tf_epc += 4;
+
+	 child_tf = (struct trapframe *) kmalloc(sizeof(struct trapframe));
+	 child_addr = (struct addrspace *) kmalloc(sizeof(struct addrspace));
+
+	 // set child v0 to 0
+	 // set parent v0 to child_pid
+
+	 // copy trapframe for child process use 
+	 // did some simple tests and memcpy is working great
+	memmove(child_tf, tf, sizeof(struct trapframe));
+	// child_tf->tf_v0 = 0;
+	// child_tf->tf_epc += 4;
+	// child_tf->tf_a3 = 0;
+	 
+	 // copy address space use as_copy
+	 as_copy(curthread->t_addrspace, &child_addr);
+	 
+	 child_param->tf = child_tf;
+	 child_param->addr = child_addr;
+	 int p_pid = curthread->process->pid;
+	 // maybe send all the info they need to copy to childs_waiting_area?
+	 thread_fork("childThread", childs_waiting_area, child_param, (unsigned long)p_pid, &newThread);
+
+	 //memcpy(newThread->t_stack, curthread->t_stack, STACK_SIZE);
+	 //newThread->process->tf = child_tf;
+	 
+	 // copy file table
+	 //memcpy(curthread->process->file_table, newThread->process->file_table, sizeof(*curthread->process->file_table)); 
+	 *retval = (int32_t)newThread->process->pid;
+
+	 //*/
+	 return 0;
+}
+
+// copy runprogram.c
+// kern/include/kern/limits.h __ARG_MAX (we may need to this to know maxium argument size)
+// we also need to copy args from users stack. these values will not be passed in through tf
+// be careful of word alignment when copy-ing from users stack a word is 32 bits (4 bytes)
+// on fail be sure to free resouces (aka locks, any data on heap, open files, etc etc)
+// TODO make sure you properly get rid of the old address space
+// TODO create some sort of limit as to the size of argv
+int sys_execv(const char * program, char* const *args) {
+	
+	int itr = 0;
+	int argc = 0;
+	int modulo = 0;
+	int argument_size = 0;
+	int arg_item_size = 0;
+	int arg_stack_mem = 0;
+	int err;
+	
+	unsigned int arg_size = 0;
+	
+	char *c;
+
+	void *argument_stack;
+	void *argument_ptr;
+
+	//lets check our arguments
+   if (program == NULL ||(vaddr_t)program < 0x400000 
+			||(((vaddr_t)program > 0x466000) && ((vaddr_t)program <= 0x40000000)) 
+			||(vaddr_t) program >= 0x80000000){
+		return EFAULT;
+	}
+	if(program == "") {
+		return EFAULT;
+	}
+   if (args == NULL ||(vaddr_t)args < 0x400000 
+			||(((vaddr_t)args > 0x466000) && ((vaddr_t)args <= 0x40000000)) 
+			||(vaddr_t) args >= 0x80000000){
+		return EFAULT;
+	}
+
+	while(args[argc] != NULL) {
+		argc++;
+		//check each individual argument if it is bad
+	   if (args[argc] == NULL ||(vaddr_t)args[argc] < 0x400000 
+			||(((vaddr_t)args[argc] > 0x466000) && ((vaddr_t)args[argc] <= 0x40000000)) 
+			||(vaddr_t) args[argc] >= 0x80000000) {
+			return EFAULT;
+		}	
+	}
+	
+	int len_program = strlen(program);
+	char kprogram[len_program+1];
+
+	char * copied_args[argc];
+
+	//might need these to make the end of the argument list. if so make sure we add one more element to the array
+	//arguments[argc] = NULL;
+
+	//this loop is to get argument size
+	while(args[itr] != NULL) {
+		c = args[itr];
+		//plus 1 used for '\0\ char
+		arg_item_size = strlen(c) + 1;
+
+		modulo = arg_item_size % 4;
+		argument_size += arg_item_size + (4 - modulo);
+		if(modulo == 0) {
+			argument_size -= 4;
+		}
+		
+		itr++;
+
+		arg_item_size = 0;
+	}
+
+	//(number of args) * 4 (size of pointer) = * 8
+	// + 4 is for null pointer between arg pointers and args
+	//This is our malloc size
+	arg_stack_mem = argument_size + (argc * 4) + 4;
+
+	//TODO free up this memory
+   argument_stack = kmalloc(arg_stack_mem);	
+
+	//TODO some sort of error return?
+	err = copyin((const_userptr_t)program, kprogram, sizeof(kprogram));
+
+	//reset itr
+	itr = 0;
+	
+	//reset things
+	arg_item_size = 0;
+	argument_size = 0;
+
+	//lets assign these variables
+	while(args[itr] != NULL) {
+
+		c = args[itr];
+		//plus 1 used for '\0\ char
+		arg_item_size = strlen(c) + 1;
+		
+		modulo = arg_item_size % 4;
+
+		//base line
+		argument_ptr = argument_stack;
+		
+		//get value
+		argument_ptr = argument_ptr + (argc * 4) + 4 + argument_size;
+
+		//strcpy	
+		copyin((const_userptr_t)args[itr], argument_ptr, strlen(args[itr]));
+		copied_args[itr] = (char *)argument_ptr;
+
+		//reset values per loop
+		argument_size += arg_item_size + (4 - modulo);
+		if(modulo == 0) {
+			argument_size -= 4;
+		}
+		itr++;
+		arg_item_size = 0;
+	}
+
+	/////////////////////////////////////////////////////
+	//***************************************************
+	/////////////////////////////////////////////////////
+	struct vnode *v;
+	vaddr_t entrypoint, stackptr;
+	int result;
+
+	/* Open the file. */
+	result = vfs_open(kprogram, O_RDONLY, 0, &v);
+	if (result) {
+		return result;
+	}
+
+	//prob don't need this
+	/* We should be a new thread. */
+	//KASSERT(curthread->t_addrspace == NULL);
+
+	/* Create a new address space. */
+	as_destroy(curthread->t_addrspace);
+	curthread->t_addrspace = as_create();
+	if (curthread->t_addrspace==NULL) {
+		vfs_close(v);
+		return ENOMEM;
+	}
+
+	/* Activate it. */
+	as_activate(curthread->t_addrspace);
+
+	/* Load the executable. */
+	result = load_elf(v, &entrypoint);
+	if (result) {
+		/* thread_exit destroys curthread->t_addrspace */
+		vfs_close(v);
+		return result;
+	}
+
+	/* Done with the file now. */
+	vfs_close(v);
+
+	/* Define the user stack in the address space */
+	result = as_define_stack(curthread->t_addrspace, &stackptr);
+	if (result) {
+		/* thread_exit destroys curthread->t_addrspace */
+		return result;
+	}
+	
+	//reset things
+	arg_item_size = 0;
+	argument_size = 0;
+
+	//lets assign these variables
+	for(int j = argc-1; j >= 0; j--) {
+
+		//TODO use vm.h values instead
+		vaddr_t tempAddress = 2147483648;
+
+		c = copied_args[j];
+		//plus 1 used for '\0\ char
+		arg_item_size = strlen(c) + 1;
+		
+		modulo = arg_item_size % 4;
+
+		//reset values per loop
+		arg_size += arg_item_size + (4 - modulo);
+		if(modulo == 0) {
+			arg_size -= 4;
+		}
+		
+		//base line
+		argument_ptr = argument_stack;
+		argument_ptr = argument_ptr + (j * 4);
+
+		tempAddress -= arg_size;	
+
+		memmove(argument_ptr, &tempAddress, 4);
+		
+		arg_item_size = 0;
+	}
+
+	//assign NULL
+	char *null_ptr;
+	
+	argument_ptr = argument_stack + (argc * 4);
+	null_ptr = (char *)argument_ptr;
+	null_ptr = NULL;
+
+	/* Open StandIn/Out/Err*/
+	char console[5];
+	struct vnode * vnode0;
+	struct vnode * vnode1;
+	struct vnode * vnode2;
+
+	strcpy(console,"con:");
+	// open Standin
+   result = vfs_open(console, O_RDONLY, 0664, &vnode0);
+	if(result){
+		return result;
+	}
+
+	file_desc * open_file_desc0 =(file_desc*) kmalloc(sizeof(file_desc));
+	bzero(open_file_desc0,sizeof(file_desc));
+
+	open_file_desc0->fldesc_lk = lock_create("filedesc_lk");
+	lock_acquire(open_file_desc0->fldesc_lk);
+		open_file_desc0->offset = 0;
+		open_file_desc0->ref_count = 1;
+		open_file_desc0->file_object = vnode0;
+   lock_release(open_file_desc0->fldesc_lk);
+	//update file table
+	curthread->process->file_table[0] = open_file_desc0;
+
+   //open standout
+	strcpy(console,"con:");
+   result = vfs_open(console, O_WRONLY, 0664, &vnode1);
+	if(result){
+		return result;
+	}
+	file_desc * open_file_desc1 =(file_desc*) kmalloc(sizeof(file_desc));
+	bzero(open_file_desc1,sizeof(file_desc));
+
+	open_file_desc1->fldesc_lk = lock_create("filedesc_lk");
+	lock_acquire(open_file_desc1->fldesc_lk);
+		open_file_desc1->offset = 0;
+		open_file_desc1->ref_count = 1;
+		open_file_desc1->file_object = vnode1;
+   lock_release(open_file_desc1->fldesc_lk);
+	//update file table
+	curthread->process->file_table[1] = open_file_desc1;
+   
+	// open standerr
+	strcpy(console,"con:");
+   result = vfs_open(console, O_WRONLY, 0664, &vnode2);
+	if(result){
+		return result;
+	}
+	file_desc * open_file_desc2 =(file_desc*) kmalloc(sizeof(file_desc));
+	bzero(open_file_desc2,sizeof(file_desc));
+
+	open_file_desc2->fldesc_lk = lock_create("filedesc_lk");
+	lock_acquire(open_file_desc2->fldesc_lk);
+		open_file_desc2->offset = 0;
+		open_file_desc2->ref_count = 1;
+		open_file_desc2->file_object = vnode2;
+   lock_release(open_file_desc2->fldesc_lk);
+	//update file table
+	curthread->process->file_table[2] = open_file_desc2;
+
+	stackptr -= arg_stack_mem;
+	copyout(argument_stack, (userptr_t)stackptr, arg_stack_mem);
+
+	//TODO clean up mallocs
+	kfree(argument_stack);
+
+	/* Warp to user mode. */
+	enter_new_process(itr, (userptr_t)stackptr /*userspace addr of argv*/,
+			  stackptr, entrypoint);
+	
+	/* enter_new_process does not return. */ 
+	panic("enter_new_process returned\n");
+	return EINVAL;
+	
+}
+
+//keep exit code from child process
+int sys_waitpid(int pid, int * status, int options, int32_t * retval) {
+ 
+	int cur_pid = curthread->process->pid;
+	// pid err checking
+	if(pid <= 1 || pid > PID_MAX -1 )
+	{
+		return ESRCH;
+	}
+   if(all_process_meta[pid].p_pid != cur_pid)
+	{
+      return ECHILD;
+	}
+   // status err checkin
+   if (status == NULL ||(vaddr_t)status < 0x400000 
+			||(((vaddr_t)status > 0x466000) && ((vaddr_t)status <= 0x40000000)) 
+			||(vaddr_t) status >= 0x80000000 || ((unsigned int)status % 4)!= 0){
+		return EFAULT;
+	}
+	// options err checking
+	if(options != 0)
+	{
+		return EINVAL;
+	}
+	lock_acquire(all_process_meta[pid].exit_lk);
+	while(1){
+		if(all_process_meta[pid].exited == 1){
+			// get exited code and release pid and process meta 
+			*status = all_process_meta[pid].exitcode;
+			all_process_meta[pid].p_pid = PID_MAX+1;
+
+			lock_acquire(process_id_lk);
+			pid_in_use[pid] = false;
+			lock_release(process_id_lk);
+
+         lock_release(all_process_meta[pid].exit_lk);
+			break;
+		}else{
+			cv_wait(all_process_meta[pid].exit_cv,all_process_meta[pid].exit_lk);
+		}
+	}
+   *retval = (int32_t)pid;
+	return 0;
+}
+
+//keep exit code from child process
+int sys_exit(int exitcode) {
+
+	int pid = curthread->process->pid;
+	lock_acquire(all_process_meta[pid].exit_lk);
+	all_process_meta[pid].exited = 1;
+	all_process_meta[pid].exitcode =(_MKWVAL(exitcode)|__WEXITED);
+	cv_broadcast(all_process_meta[pid].exit_cv,all_process_meta[pid].exit_lk);
+	lock_release(all_process_meta[pid].exit_lk);
+	thread_exit();
+
+	return 0;
+}
diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
index a6f45c8..18fc627 100644
--- a/kern/syscall/runprogram.c
+++ b/kern/syscall/runprogram.c
@@ -54,6 +54,7 @@
 int
 runprogram(char *progname)
 {
+
 	struct vnode *v;
 	vaddr_t entrypoint, stackptr;
 	int result;
@@ -95,12 +96,76 @@ runprogram(char *progname)
 		return result;
 	}
 
+	/* Open StandIn/Out/Err*/
+	char console[5];
+	struct vnode * vnode0;
+	struct vnode * vnode1;
+	struct vnode * vnode2;
+
+	strcpy(console,"con:");
+	// open Standin
+   result = vfs_open(console, O_RDONLY, 0664, &vnode0);
+	if(result){
+		return result;
+	}
+
+	file_desc * open_file_desc0 =(file_desc*) kmalloc(sizeof(file_desc));
+	bzero(open_file_desc0,sizeof(file_desc));
+
+	open_file_desc0->fldesc_lk = lock_create("filedesc_lk");
+	lock_acquire(open_file_desc0->fldesc_lk);
+		open_file_desc0->offset = 0;
+		open_file_desc0->ref_count = 1;
+		open_file_desc0->file_object = vnode0;
+		open_file_desc0->file_access = O_RDONLY;
+   lock_release(open_file_desc0->fldesc_lk);
+	//update file table
+	curthread->process->file_table[0] = open_file_desc0;
+
+   //open standout
+	strcpy(console,"con:");
+   result = vfs_open(console, O_WRONLY, 0664, &vnode1);
+	if(result){
+		return result;
+	}
+	file_desc * open_file_desc1 =(file_desc*) kmalloc(sizeof(file_desc));
+	bzero(open_file_desc1,sizeof(file_desc));
+
+	open_file_desc1->fldesc_lk = lock_create("filedesc_lk");
+	lock_acquire(open_file_desc1->fldesc_lk);
+		open_file_desc1->offset = 0;
+		open_file_desc1->ref_count = 1;
+		open_file_desc1->file_object = vnode1;
+		open_file_desc1->file_access = O_WRONLY;
+   lock_release(open_file_desc1->fldesc_lk);
+	//update file table
+	curthread->process->file_table[1] = open_file_desc1;
+   
+	// open standerr
+	strcpy(console,"con:");
+   result = vfs_open(console, O_WRONLY, 0664, &vnode2);
+	if(result){
+		return result;
+	}
+	file_desc * open_file_desc2 =(file_desc*) kmalloc(sizeof(file_desc));
+	bzero(open_file_desc2,sizeof(file_desc));
+
+	open_file_desc2->fldesc_lk = lock_create("filedesc_lk");
+	lock_acquire(open_file_desc2->fldesc_lk);
+		open_file_desc2->offset = 0;
+		open_file_desc2->ref_count = 1;
+		open_file_desc2->file_object = vnode2;
+		open_file_desc2->file_access = O_WRONLY;
+   lock_release(open_file_desc2->fldesc_lk);
+	//update file table
+	curthread->process->file_table[2] = open_file_desc2;
+
 	/* Warp to user mode. */
 	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
 			  stackptr, entrypoint);
 	
-	/* enter_new_process does not return. */
+	/* enter_new_process does not return. */ 
 	panic("enter_new_process returned\n");
 	return EINVAL;
 }
-
+ 
diff --git a/kern/syscall/sys_file.c b/kern/syscall/sys_file.c
new file mode 100644
index 0000000..bced030
--- /dev/null
+++ b/kern/syscall/sys_file.c
@@ -0,0 +1,336 @@
+#include <types.h>
+#include <copyinout.h>
+#include <syscall.h>
+#include <process.h>
+#include <limits.h>
+#include <uio.h>
+#include <kern/seek.h>
+#include <vnode.h>
+#include <kern/stat.h>
+
+struct vnode;
+struct file_desc;
+struct uio;
+struct iovec;
+struct stat;
+
+int sys_open(const char *filename, int flags, size_t mode, int32_t *retval)
+{
+	 
+	//Erro Detection 
+   if (filename == NULL ||(vaddr_t)filename < 0x400000 
+			||(((vaddr_t)filename > 0x466000) && ((vaddr_t)filename <= 0x40000000)) 
+			||(vaddr_t) filename >= 0x80000000){
+		return EFAULT;
+	}
+	if(filename == ""){
+		return EINVAL;
+	}
+	if(curthread->process->ft_counter==OPEN_MAX-1){ 	
+		return EMFILE;
+	}
+	int err;
+	int filehandle=get_file_handle(curthread->process);
+	if (filehandle > OPEN_MAX-1){
+      return EBADF;
+	}
+
+   const char * lk_name="fldesc_lk";
+   struct vnode *vnode;
+	char kfilename[PATH_MAX];
+	size_t gotlen=0;
+
+	// kmalloc space for filedesc
+	file_desc * open_file_desc =(file_desc*) kmalloc(sizeof(file_desc));
+	bzero(open_file_desc,sizeof(file_desc));
+
+	//copy user space to kernel space
+	err = copyinstr((const_userptr_t)filename,kfilename,PATH_MAX,&gotlen);
+	if(err)
+	{
+		return err;
+	}
+   err = vfs_open(kfilename,flags,mode,&vnode);
+	if(err)
+	{
+		return err;
+	}
+	//modify shared data: offset and ref-count
+	open_file_desc->fldesc_lk = lock_create(lk_name);
+	
+	lock_acquire(open_file_desc->fldesc_lk);
+		open_file_desc->offset = 0;
+		open_file_desc->file_object = vnode;
+		if(flags & O_APPEND)
+		{
+			struct stat vnstat;
+			err = VOP_STAT(curthread->process->file_table[filehandle]->file_object, &vnstat);
+			if(err){
+				return err;
+			}
+		   open_file_desc->offset = vnstat.st_size-1;
+		}
+		open_file_desc->ref_count = 1;
+		open_file_desc->file_access = flags;
+   lock_release(open_file_desc->fldesc_lk);
+
+	//update file table
+	curthread->process->file_table[filehandle] = open_file_desc;
+	*retval=(int32_t)filehandle;
+	
+	return 0;
+}
+
+int  sys_read(int filehandle, void *buf, size_t size, int32_t* retval)
+{
+	// File must be open before reading
+	if(filehandle < 0 || filehandle > OPEN_MAX-1
+			|| curthread->process->file_table[filehandle] == NULL){
+ 		return EBADF;
+	}
+   // Buf should be valid
+   if (buf == NULL ||(vaddr_t)buf < 0x400000 
+			||(((vaddr_t)buf > 0x466000) && ((vaddr_t)buf <= 0x40000000)) 
+			||(vaddr_t) buf >= 0x80000000){
+		return EFAULT;
+	}
+	if(curthread->process->ft_counter==OPEN_MAX-1){ 	
+		return EMFILE;
+	}
+   if(curthread->process->file_table[filehandle]->file_access == O_WRONLY){
+		return EBADF;
+	}
+	/*if((filehandle == 0) && (curthread->process->file_table[0]->file_access == O_RDWR)){
+		return EBADF;
+	}*/
+   int result;
+	struct uio ruio;
+   struct iovec riovec;
+	void *rbuf[size];
+   bzero(rbuf,sizeof(rbuf));
+
+	 off_t pos = curthread->process->file_table[filehandle]->offset;
+	 uio_kinit(&riovec, &ruio, rbuf, size, pos, UIO_READ);
+    // read should be atomic
+	 lock_acquire(curthread->process->file_table[filehandle]->fldesc_lk);
+	 VOP_READ(curthread->process->file_table[filehandle]->file_object, &ruio);
+	 int bytesread = size -ruio.uio_resid;
+	 if(bytesread < 0){
+		return EFAULT;
+	 }
+	 curthread->process->file_table[filehandle]->offset += (off_t)bytesread;
+	 lock_release(curthread->process->file_table[filehandle]->fldesc_lk);
+
+	 result = copyout(rbuf,(userptr_t)buf,size);
+	 if(result){
+		 return result;
+	 }
+	*retval = bytesread;
+	return 0;
+}
+
+int sys_write(int filehandle, const void *buf, size_t size, int32_t* retval)
+{
+   void * wbuf[size];
+	bzero(wbuf,sizeof(wbuf));
+
+	int result;
+   result =	copyin((const_userptr_t)buf, wbuf, size);
+   if(result){
+		return result;
+	}
+	if(filehandle < 0 || filehandle > OPEN_MAX-1
+			|| curthread->process->file_table[filehandle] == NULL){
+ 		return EBADF;
+	}
+   // Buf should ne valid
+   if (buf == NULL ||(vaddr_t)buf < 0x400000 
+			||(((vaddr_t)buf > 0x466000) && ((vaddr_t)buf <= 0x40000000)) 
+			||(vaddr_t) buf >= 0x80000000){
+		return EFAULT;
+	}
+	if(curthread->process->file_table[filehandle]->file_access == O_RDONLY){
+     return EBADF;
+	}
+	/*if(((filehandle == 1) || (filehandle == 2)) && (curthread->process->file_table[filehandle]->file_access == O_RDWR )){
+     return EBADF;
+	}*/
+	 struct uio wuio;
+	 struct iovec wiovec;
+    off_t pos = curthread->process->file_table[filehandle]->offset;
+
+	 uio_kinit(&wiovec, &wuio, wbuf, size, pos, UIO_WRITE);
+    // read should be atomic
+	 lock_acquire(curthread->process->file_table[filehandle]->fldesc_lk);
+	 VOP_WRITE(curthread->process->file_table[filehandle]->file_object, &wuio);
+	 int byteswrite = size -wuio.uio_resid;
+	 if(byteswrite < 0){
+		return EFAULT;
+	 }
+	 curthread->process->file_table[filehandle]->offset += (off_t)byteswrite;
+	 lock_release(curthread->process->file_table[filehandle]->fldesc_lk);
+	
+	 *retval=byteswrite;
+	 return 0;
+}
+
+int sys_close(int filehandle)
+{
+   if(filehandle < 0 || filehandle > OPEN_MAX-1 ||
+		  	curthread->process->file_table[filehandle] == NULL){
+      return EBADF;
+	}
+
+   if(curthread->process->file_table[filehandle]->ref_count < 1){
+		return EBADF;
+	}
+ /*  if(filehandle == 0 || filehandle == 1 || filehandle == 2){
+		
+		vfs_close(curthread->process->file_table[filehandle]->file_object);
+		kfree(curthread->process->file_table[filehandle]);
+      curthread->process->file_table[filehandle] = NULL;
+		return 0;
+	}*/
+   if(curthread->process->file_table[filehandle]->ref_count > 1){
+		lock_acquire(curthread->process->file_table[filehandle]->fldesc_lk);
+		curthread->process->file_table[filehandle]->ref_count--;
+		lock_release(curthread->process->file_table[filehandle]->fldesc_lk);
+		curthread->process->file_table[filehandle] = NULL;
+		return 0;
+	}
+
+	if(curthread->process->file_table[filehandle]->ref_count == 1){
+		vfs_close(curthread->process->file_table[filehandle]->file_object);
+		kfree(curthread->process->file_table[filehandle]);
+      curthread->process->file_table[filehandle] = NULL;
+	}
+	return 0;
+}
+
+int sys_dup2(int oldhandle, int newhandle, int32_t* retval)
+{
+	// oldhandle and newhandle should be in the bound, and old handle should be open
+	if(oldhandle < 0 || newhandle < 0 || oldhandle > OPEN_MAX-1 || newhandle > OPEN_MAX-1
+    	|| curthread->process->file_table[oldhandle] == NULL){
+		return EBADF;
+	}
+	if(curthread->process->ft_counter >= OPEN_MAX-1){ 	
+		return EMFILE;
+	}
+	// if oldhandle = newhandle,just return newhanlde
+	if(oldhandle == newhandle){
+		*retval = newhandle;
+		return 0;
+	}
+	// if newhandle is open ,close it before dup2
+	if(curthread->process->file_table[newhandle] != NULL){
+		sys_close(newhandle);
+	} 
+   
+	lock_acquire(curthread->process->file_table[oldhandle]->fldesc_lk);
+	curthread->process->file_table[oldhandle]-> ref_count++;
+   lock_release(curthread->process->file_table[oldhandle]->fldesc_lk);
+	curthread->process->file_table[newhandle] = curthread->process->file_table[oldhandle];
+
+	*retval=newhandle;
+	return 0;
+}
+
+int sys_chdir(char *path)
+{
+   if (path == NULL || path == "" ||(vaddr_t)path < 0x400000 
+			||(((vaddr_t)path > 0x466000) && ((vaddr_t)path <= 0x40000000)) 
+			||(vaddr_t) path >= 0x80000000){
+		return EFAULT;
+	}
+
+	int result;
+	char kpath[PATH_MAX];
+	result = copyin((const_userptr_t)path, kpath, PATH_MAX);
+   if(result){
+		return result;
+	}
+	result=vfs_chdir(kpath);
+	if(result){
+		return result;
+	}
+	return 0;
+}
+
+off_t sys_lseek(int filehandle, off_t pos, int code, int32_t* retval, uint32_t * tfv1)
+{
+   if(filehandle < 0 || filehandle > OPEN_MAX-1 || curthread->process->file_table[filehandle] == NULL){
+		return EBADF;
+	}
+	/*if(filehandle == 0 ||filehandle == 1 || filehandle ==2 ){
+		return EBADF;
+	}*/
+
+	off_t retv;
+	struct stat vnstat;
+   int result = 0;
+
+	switch(code){
+		case SEEK_SET:
+			retv = pos;
+			break;
+		case SEEK_CUR:
+			retv =  curthread->process->file_table[filehandle]->offset + pos;
+			break;
+		case SEEK_END:
+			result = VOP_STAT(curthread->process->file_table[filehandle]->file_object, &vnstat);
+			if(result){
+				return result;
+			}
+			retv = vnstat.st_size + pos;
+			break;
+		default:
+			return EINVAL;
+	}
+	if(retv < 0){
+		return EINVAL;
+	}
+	// TRYSEEK
+	result = VOP_TRYSEEK(curthread->process->file_table[filehandle]->file_object, retv);
+	if(result){
+		return result;
+	}
+   lock_acquire(curthread->process->file_table[filehandle]->fldesc_lk);
+	curthread->process->file_table[filehandle]->offset = retv;
+	lock_release(curthread->process->file_table[filehandle]->fldesc_lk);
+
+	*retval =(int32_t)(retv >> 32);
+	*tfv1 = (uint32_t)retv;
+	
+	return 0;
+}
+
+int sys_getcwd(char *buf, size_t buflen, int32_t *retval)
+{
+   struct uio cwduio;
+	struct iovec  cwdiovec;
+	int result;
+   char kbuf[buflen+1];
+	bzero(kbuf, sizeof(kbuf));
+
+   if (buf == NULL ||(vaddr_t)buf < 0x400000 
+			||(((vaddr_t)buf > 0x466000) && ((vaddr_t)buf <= 0x40000000)) 
+			||(vaddr_t) buf >= 0x80000000){
+		return EFAULT;
+	}
+	uio_kinit(&cwdiovec, &cwduio, kbuf, buflen, 0, UIO_READ);
+	result = vfs_getcwd(&cwduio);
+	if(result){
+			return result;	
+	}
+
+	result = copyout(kbuf,(userptr_t)buf, sizeof(kbuf));
+	if(result){
+		return result;
+	}
+
+   *retval = (int32_t)(buflen-cwduio.uio_resid);
+	return 0;
+}
+
+ 
diff --git a/kern/test/synchtest.c b/kern/test/synchtest.c
index d072469..9abf9c1 100644
--- a/kern/test/synchtest.c
+++ b/kern/test/synchtest.c
@@ -41,7 +41,10 @@
 #define NSEMLOOPS     63
 #define NLOCKLOOPS    120
 #define NCVLOOPS      5
+#define NRWLOOPS		 5
 #define NTHREADS      32
+#define WTHREADS		 20
+#define RTHREADS		 52
 
 static volatile unsigned long testval1;
 static volatile unsigned long testval2;
@@ -49,6 +52,7 @@ static volatile unsigned long testval3;
 static struct semaphore *testsem;
 static struct lock *testlock;
 static struct cv *testcv;
+static struct rwlock *testrw;
 static struct semaphore *donesem;
 
 static
@@ -79,6 +83,12 @@ inititems(void)
 			panic("synchtest: sem_create failed\n");
 		}
 	}
+	if (testrw==NULL) {
+		testrw = rwlock_create("testrw");
+		if (testrw == NULL) {
+			panic("synchtest: rw_create failed\n");
+		}
+	}
 }
 
 static
@@ -263,8 +273,9 @@ cvtestthread(void *junk, unsigned long num)
 		 * loop a little while to make sure we can measure the
 		 * time waiting on the cv.
 		 */
+		
 		for (j=0; j<3000; j++);
-
+		
 		cv_broadcast(testcv, testlock);
 		lock_release(testlock);
 	}
@@ -331,7 +342,7 @@ int
 cvtest2(int nargs, char **args)
 {
 	int i, result;
-
+	
 	(void)nargs;
 	(void)args;
 
diff --git a/kern/thread/synch.c b/kern/thread/synch.c
index 9a7468c..55ef2b6 100644
--- a/kern/thread/synch.c
+++ b/kern/thread/synch.c
@@ -150,8 +150,8 @@ V(struct semaphore *sem)
 struct lock *
 lock_create(const char *name)
 {
+		
         struct lock *lock;
-
         lock = kmalloc(sizeof(struct lock));
         if (lock == NULL) {
                 return NULL;
@@ -162,9 +162,18 @@ lock_create(const char *name)
                 kfree(lock);
                 return NULL;
         }
-        
-        // add stuff here as needed
-        
+       					    
+		  //* 
+		  lock->lk_wchan = wchan_create(lock->lk_name);
+		  if(lock->lk_wchan == NULL) {
+				kfree(lock->lk_name);
+				kfree(lock);
+				return NULL;
+		  }
+		  
+		  spinlock_init(&lock->lk_lock);
+		  lock->lk_holder = NULL;
+		   //*/
         return lock;
 }
 
@@ -173,36 +182,61 @@ lock_destroy(struct lock *lock)
 {
         KASSERT(lock != NULL);
 
-        // add stuff here as needed
+       KASSERT(lock->lk_holder == NULL);
         
-        kfree(lock->lk_name);
+		  spinlock_cleanup(&lock->lk_lock);
+		  wchan_destroy(lock->lk_wchan);
+        
+		  kfree(lock->lk_name);
         kfree(lock);
 }
 
 void
 lock_acquire(struct lock *lock)
 {
-        // Write this
-
-        (void)lock;  // suppress warning until code gets written
+      	DEBUGASSERT(lock != NULL);
+			KASSERT(curthread->t_in_interrupt == false);
+
+			spinlock_acquire(&lock->lk_lock);
+			while(lock->lk_holder != NULL) {
+				//someone else has the lock
+				wchan_lock(lock->lk_wchan);
+				spinlock_release(&lock->lk_lock);
+				//lets sleep until the lock is released
+				wchan_sleep(lock->lk_wchan);
+				spinlock_acquire(&lock->lk_lock);
+			}
+
+			lock->lk_holder = curthread;
+			spinlock_release(&lock->lk_lock);
 }
 
 void
 lock_release(struct lock *lock)
 {
-        // Write this
-
-        (void)lock;  // suppress warning until code gets written
+      DEBUGASSERT(lock != NULL);
+		spinlock_acquire(&lock->lk_lock);
+		
+		lock->lk_holder = NULL;
+
+		wchan_wakeone(lock->lk_wchan);
+		
+		spinlock_release(&lock->lk_lock);
+		
 }
 
 bool
 lock_do_i_hold(struct lock *lock)
 {
-        // Write this
+			bool ret;
 
-        (void)lock;  // suppress warning until code gets written
+			DEBUGASSERT(lock != NULL);
 
-        return true; // dummy until code gets written
+			spinlock_acquire(&lock->lk_lock);
+			ret = (lock->lk_holder == curthread);
+			spinlock_release(&lock->lk_lock);
+        
+		  return ret; 
 }
 
 ////////////////////////////////////////////////////////////
@@ -225,43 +259,123 @@ cv_create(const char *name)
                 kfree(cv);
                 return NULL;
         }
-        
-        // add stuff here as needed
-        
+       
+		  cv->cv_wchan = wchan_create(cv->cv_name);
+		  if(cv->cv_wchan == NULL) {
+				kfree(cv->cv_wchan);
+				kfree(cv);
+				return NULL;
+		  }
+
+			//spinlock_init(&cv->cv_lock);
+
         return cv;
 }
 
 void
 cv_destroy(struct cv *cv)
 {
-        KASSERT(cv != NULL);
+	KASSERT(cv != NULL);
+
+	wchan_destroy(cv->cv_wchan);
+		  
+	kfree(cv->cv_name);
+	kfree(cv);
 
-        // add stuff here as needed
-        
-        kfree(cv->cv_name);
-        kfree(cv);
 }
 
 void
 cv_wait(struct cv *cv, struct lock *lock)
 {
-        // Write this
-        (void)cv;    // suppress warning until code gets written
-        (void)lock;  // suppress warning until code gets written
+		wchan_lock(cv->cv_wchan);
+		lock_release(lock);
+		wchan_sleep(cv->cv_wchan);
+		lock_acquire(lock); 
 }
 
 void
 cv_signal(struct cv *cv, struct lock *lock)
 {
-        // Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+	(void)lock;
+	wchan_wakeone(cv->cv_wchan);
 }
 
 void
 cv_broadcast(struct cv *cv, struct lock *lock)
 {
-	// Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+	(void)lock;
+	wchan_wakeall(cv->cv_wchan);
+}
+
+struct rwlock * rwlock_create(const char *name) 
+{
+   struct rwlock *rw;
+
+	//allocate necessary memory
+	rw = kmalloc(sizeof(struct rwlock));
+	if(rw == NULL) {
+		return NULL;
+	}
+
+	//assign a name to this rwlock
+	rw->rwlock_name = kstrdup(name);
+	if(rw->rwlock_name == NULL) {
+		kfree(rw);
+		return NULL;
+	}
+
+	//create the needed semaphores
+	rw->writing = sem_create("writing", 1);
+	rw->reading = sem_create("reading", 1);
+	rw->reader_count = sem_create("reader_count", 1);
+
+	//set the reader count to 0
+	rw->reader_counter = 0;
+	
+	return rw;
+}
+void rwlock_destroy(struct rwlock * rw)
+{
+	sem_destroy(rw->writing);
+	sem_destroy(rw->reading);
+	sem_destroy(rw->reader_count);
+	kfree(rw->rwlock_name);
+	kfree(rw);
+}
+void rwlock_acquire_read(struct rwlock *rw)
+{
+	int number_of_readers;
+	P(rw->writing);
+	P(rw->reader_count);
+		number_of_readers = rw->reader_counter;
+		rw->reader_counter = rw->reader_counter + 1;
+	V(rw->reader_count);
+	if(number_of_readers == 0) {
+		P(rw->reading);
+	}
+	V(rw->writing);
+}
+void rwlock_release_read(struct rwlock *rw) 
+{
+	int number_of_readers;
+	P(rw->reader_count);
+		rw->reader_counter = rw->reader_counter - 1;
+		number_of_readers = rw->reader_counter;
+	V(rw->reader_count);
+	if(number_of_readers == 0) {
+		V(rw->reading);
+	}
+}
+void rwlock_acquire_write(struct rwlock *rw)
+{
+	//are there are writers in front of me? if so get in line.
+	P(rw->writing);
+	//is anyone reading? if so get in line.
+	P(rw->reading);
+}
+void rwlock_release_write(struct rwlock *rw) 
+{
+	//done writing
+	V(rw->reading);
+	V(rw->writing);
 }
diff --git a/kern/thread/thread.c b/kern/thread/thread.c
index 5b8099e..ffc567d 100644
--- a/kern/thread/thread.c
+++ b/kern/thread/thread.c
@@ -55,6 +55,11 @@
 /* Magic number used as a guard value on kernel thread stacks. */
 #define THREAD_STACK_MAGIC 0xbaadf00d
 
+//for processes
+extern volatile bool pid_in_use[PID_MAX];
+extern struct meta_process all_process_meta[PID_MAX];
+struct file_desc;
+
 /* Wait channel. */
 struct wchan {
 	const char *wc_name;		/* name for this channel */
@@ -153,6 +158,14 @@ thread_create(const char *name)
 	thread->t_cwd = NULL;
 
 	/* If you add to struct thread, be sure to initialize here */
+	thread->process = kmalloc(sizeof(*thread->process));
+	thread->process->ft_counter = 3;
+	for(int i = 0; i< OPEN_MAX; i++)
+	{
+		thread->process->file_table[i] = NULL;
+	}
+	thread->priority_level = 1;
+	// we need this for fork, but only for fork.
 
 	return thread;
 }
@@ -262,8 +275,30 @@ thread_destroy(struct thread *thread)
 	/* sheer paranoia */
 	thread->t_wchan_name = "DESTROYED";
 
+	//release file table
+	/*  for(int i = 3; i < OPEN_MAX-1; i++){
+		if(thread->process->file_table[i] == NULL){
+        kfree(thread->process->file_table[i]);
+		}else{
+			if(thread->process->file_table[i]->ref_count == 1){
+      	   lock_destroy(thread->process->file_table[i]->fldesc_lk);
+				kfree(thread->process->file_table[i]);
+		 		continue;
+			}
+			if(thread->process->file_table[i]->ref_count > 1){
+      	lock_acquire(thread->process->file_table[i]->fldesc_lk);
+			thread->process->file_table[i]->ref_count --;
+			lock_release(thread->process->file_table[i]->fldesc_lk);
+			}	
+		}
+	}*/
+	//release process struct
+	kfree(thread->process);
+
 	kfree(thread->t_name);
 	kfree(thread);
+
+	//release process
 }
 
 /*
@@ -382,6 +417,7 @@ thread_bootstrap(void)
 	curcpu->c_curthread = curthread;
 
 	/* Done */
+	process_init();
 }
 
 /*
@@ -519,10 +555,93 @@ thread_fork(const char *name,
 	 * for the spllower() that will be done releasing it.
 	 */
 	newthread->t_iplhigh_count++;
+   // create pid and copy file table
+	newthread->process->pid = create_process_id();
+	newthread->process->ft_counter = curthread->process->ft_counter;
+	for(int i = 3; i < OPEN_MAX-1; i++){
+		if(curthread->process->file_table[i] != NULL){
+			lock_acquire(curthread->process->file_table[i]->fldesc_lk);
+			curthread->process->file_table[i]->ref_count ++;
+			lock_release(curthread->process->file_table[i]->fldesc_lk);
+		}
+		newthread->process->file_table[i] = curthread->process-> file_table[i]; 
+	}
+
+	/* Open StandIn/Out/Err*/
+	char console[5];
+	struct vnode * vnode0;
+	struct vnode * vnode1;
+	struct vnode * vnode2;
+   int result;
+
+	strcpy(console,"con:");
+	// open Standin
+   result = vfs_open(console, O_RDONLY, 0664, &vnode0);
+	if(result){
+		return result;
+	}
+
+	file_desc * open_file_desc0 =(file_desc*) kmalloc(sizeof(file_desc));
+	bzero(open_file_desc0,sizeof(file_desc));
+
+	open_file_desc0->fldesc_lk = lock_create("filedesc_lk");
+	lock_acquire(open_file_desc0->fldesc_lk);
+		open_file_desc0->offset = 0;
+		open_file_desc0->ref_count = 1;
+		open_file_desc0->file_object = vnode0;
+		open_file_desc0->file_access = O_RDONLY;
+   lock_release(open_file_desc0->fldesc_lk);
+	//update file table
+	newthread->process->file_table[0] = open_file_desc0;
+
+   //open standout
+	strcpy(console,"con:");
+   result = vfs_open(console, O_WRONLY, 0664, &vnode1);
+	if(result){
+		return result;
+	}
+	file_desc * open_file_desc1 =(file_desc*) kmalloc(sizeof(file_desc));
+	bzero(open_file_desc1,sizeof(file_desc));
+
+	open_file_desc1->fldesc_lk = lock_create("filedesc_lk");
+	lock_acquire(open_file_desc1->fldesc_lk);
+		open_file_desc1->offset = 0;
+		open_file_desc1->ref_count = 1;
+		open_file_desc1->file_object = vnode1;
+		open_file_desc1->file_access = O_WRONLY;
+   lock_release(open_file_desc1->fldesc_lk);
+	//update file table
+	newthread->process->file_table[1] = open_file_desc1;
+   
+	// open standerr
+	strcpy(console,"con:");
+   result = vfs_open(console, O_WRONLY, 0664, &vnode2);
+	if(result){
+		return result;
+	}
+	file_desc * open_file_desc2 =(file_desc*) kmalloc(sizeof(file_desc));
+	bzero(open_file_desc2,sizeof(file_desc));
+
+	open_file_desc2->fldesc_lk = lock_create("filedesc_lk");
+	lock_acquire(open_file_desc2->fldesc_lk);
+		open_file_desc2->offset = 0;
+		open_file_desc2->ref_count = 1;
+		open_file_desc2->file_object = vnode2;
+		open_file_desc2->file_access = O_WRONLY;
+   lock_release(open_file_desc2->fldesc_lk);
+	//update file table
+	newthread->process->file_table[2] = open_file_desc2;
+   
+	//update global process-meta
+	all_process_meta[newthread->process->pid].exit_cv = cv_create("exit_cv");
+	all_process_meta[newthread->process->pid].exit_lk = lock_create("exit_lk");
+   lock_acquire(all_process_meta[newthread->process->pid].exit_lk);
+	all_process_meta[newthread->process->pid].p_pid = (int)data2;
+	all_process_meta[newthread->process->pid].exited = 0;
+	lock_release(all_process_meta[newthread->process->pid].exit_lk);
 
 	/* Set up the switchframe so entrypoint() gets called */
 	switchframe_init(newthread, entrypoint, data1, data2);
-
 	/* Lock the current cpu's run queue and make the new thread runnable */
 	thread_make_runnable(newthread, false);
 
@@ -590,9 +709,15 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
 	    case S_RUN:
 		panic("Illegal S_RUN in thread_switch\n");
 	    case S_READY:
+		if (cur->priority_level > 1){
+		cur->priority_level --;
+		}
 		thread_make_runnable(cur, true /*have lock*/);
 		break;
 	    case S_SLEEP:
+		if(cur->priority_level < PRIORITY_SIZE){
+			cur->priority_level ++;
+		}
 		cur->t_wchan_name = wc->wc_name;
 		/*
 		 * Add the thread to the list in the wait channel, and
@@ -852,6 +977,40 @@ schedule(void)
 {
   // 28 Feb 2012 : GWA : Implement your scheduler that prioritizes
   // "interactive" threads here.
+  struct thread* max_pri_thread = NULL;
+  struct threadlistnode* iter; 
+  int max_priority;
+  int flag;
+
+  spinlock_acquire(&curcpu->c_runqueue_lock);
+  iter = curcpu->c_runqueue.tl_head.tln_next;
+  flag = 0;
+  // move the highest priority thread to runqueue head
+  for(max_priority = PRIORITY_SIZE; max_priority > 1; max_priority --){
+	  while (iter->tln_next != NULL){
+		  if (iter->tln_self->priority_level == max_priority){
+			  max_pri_thread = iter->tln_self;
+			  flag =1;
+			  break;
+		  }
+		  iter = iter->tln_next;
+	  }
+	  if(flag){
+			threadlist_remove(&curcpu->c_runqueue, max_pri_thread);
+			threadlist_addhead(&curcpu->c_runqueue, max_pri_thread);
+	  }
+
+  }
+
+  //rebalance runqueue
+  if(curcpu->c_hardclocks % RESET_PRIORITY_PRIOD == 0){
+		for(struct threadlistnode* reset_threadlistnode = curcpu->c_runqueue.tl_head.tln_next;
+				reset_threadlistnode->tln_next != NULL;
+			  	reset_threadlistnode = reset_threadlistnode->tln_next){
+			reset_threadlistnode->tln_self->priority_level = 1;
+		}
+  }
+  spinlock_release(&curcpu->c_runqueue_lock);
 }
 #endif
 
@@ -880,6 +1039,8 @@ thread_consider_migration(void)
 	struct cpu *c;
 	struct threadlist victims;
 	struct thread *t;
+	
+	DEBUG(DB_THREADS, "consider thread migration");
 
 	my_count = total_count = 0;
 	numcpus = cpuarray_num(&allcpus);
@@ -996,6 +1157,8 @@ wchan_create(const char *name)
 {
 	struct wchan *wc;
 
+	DEBUG(DB_THREADS, "wait channel created");
+
 	wc = kmalloc(sizeof(*wc));
 	if (wc == NULL) {
 		return NULL;
@@ -1013,6 +1176,9 @@ wchan_create(const char *name)
 void
 wchan_destroy(struct wchan *wc)
 {
+
+	DEBUG(DB_THREADS, "wait channel destroyed");
+
 	spinlock_cleanup(&wc->wc_lock);
 	threadlist_cleanup(&wc->wc_threads);
 	kfree(wc);
@@ -1024,12 +1190,19 @@ wchan_destroy(struct wchan *wc)
 void
 wchan_lock(struct wchan *wc)
 {
+
+	DEBUG(DB_THREADS, "wait channel locked");
+
 	spinlock_acquire(&wc->wc_lock);
 }
 
 void
 wchan_unlock(struct wchan *wc)
 {
+
+	DEBUG(DB_THREADS, "wait channel unlocked");
+
+
 	spinlock_release(&wc->wc_lock);
 }
 
@@ -1042,7 +1215,10 @@ wchan_unlock(struct wchan *wc)
 void
 wchan_sleep(struct wchan *wc)
 {
-	/* may not sleep in an interrupt handler */
+	
+	DEBUG(DB_THREADS, "wait channel sleep");
+
+/* may not sleep in an interrupt handler */
 	KASSERT(!curthread->t_in_interrupt);
 
 	thread_switch(S_SLEEP, wc);
@@ -1056,6 +1232,8 @@ wchan_wakeone(struct wchan *wc)
 {
 	struct thread *target;
 
+	DEBUG(DB_THREADS, "Wake up one thread");
+
 	/* Lock the channel and grab a thread from it */
 	spinlock_acquire(&wc->wc_lock);
 	target = threadlist_remhead(&wc->wc_threads);
@@ -1079,6 +1257,9 @@ wchan_wakeone(struct wchan *wc)
 void
 wchan_wakeall(struct wchan *wc)
 {
+
+	DEBUG(DB_THREADS, "Wake up all threads");
+
 	struct thread *target;
 	struct threadlist list;
 
diff --git a/user/sbin/reboot/reboot.c b/user/sbin/reboot/reboot.c
index 37ff4f6..3fca5c5 100644
--- a/user/sbin/reboot/reboot.c
+++ b/user/sbin/reboot/reboot.c
@@ -29,6 +29,10 @@
 
 #include <unistd.h>
 
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <err.h>
 /*
  * reboot - shut down system and reboot it.
  * Usage: reboot
@@ -41,4 +45,5 @@ main()
 {
 	reboot(RB_REBOOT);
 	return 0;
+
 }
diff --git a/user/testbin/Makefile b/user/testbin/Makefile
index c3b97a8..e7f2259 100644
--- a/user/testbin/Makefile
+++ b/user/testbin/Makefile
@@ -6,7 +6,7 @@ TOP=../..
 .include "$(TOP)/mk/os161.config.mk"
 
 SUBDIRS=add argtest badcall bigfile conman crash ctest dirconc dirseek \
-	dirtest f_test farm faulter filetest forkbomb forktest guzzle \
+	dirtest f_test farm faulter fileonlytest filetest forkbomb forktest guzzle \
 	hash hog huge kitchen malloctest matmult palin parallelvm psort \
 	randcall rmdirtest rmtest sink sort sty tail tictac triplehuge \
 	triplemat triplesort
diff --git a/user/testbin/fileonlytest/Makefile b/user/testbin/fileonlytest/Makefile
new file mode 100644
index 0000000..156fc41
--- /dev/null
+++ b/user/testbin/fileonlytest/Makefile
@@ -0,0 +1,11 @@
+# Makefile for fileonlytest
+
+TOP=../../..
+.include "$(TOP)/mk/os161.config.mk"
+
+PROG=fileonlytest
+SRCS=fileonlytest.c
+BINDIR=/testbin
+
+.include "$(TOP)/mk/os161.prog.mk"
+
diff --git a/user/testbin/fileonlytest/fileonlytest.c b/user/testbin/fileonlytest/fileonlytest.c
new file mode 100644
index 0000000..b807ff6
--- /dev/null
+++ b/user/testbin/fileonlytest/fileonlytest.c
@@ -0,0 +1,167 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * rmtest.c
+ *
+ * 	Tests file system synchronization by deleting an open file and
+ * 	then attempting to read it.
+ *
+ * This should run correctly when the file system assignment is complete.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <err.h>
+
+// 23 Mar 2012 : GWA : BUFFER_COUNT must be even.
+
+#define BUFFER_COUNT 128
+#define BUFFER_SIZE 128
+
+static int writebuf[BUFFER_SIZE];
+static int readbuf[BUFFER_SIZE];
+
+int
+main(int argc, char **argv)
+{
+
+	// 23 Mar 2012 : GWA : Assume argument passing is *not* supported.
+	
+	(void) argc;
+	(void) argv;
+	int i, j;
+	int fh, len;
+	off_t pos, target;
+
+	const char * filename = "fileonlytest.dat";
+
+	// 23 Mar 2012 : GWA : Test that open works.
+
+	printf("Opening %s\n", filename);
+
+	fh = open(filename, O_RDWR|O_CREAT|O_TRUNC);
+	if (fh < 0) {
+		err(1, "create failed");
+	}
+	
+	printf("Writing %d bytes.\n", BUFFER_SIZE * BUFFER_COUNT);
+
+  // 23 Mar 2012 : GWA : Do the even-numbered writes. Test read() and
+  // lseek(SEEK_END).
+  
+  for (i = 0; i < BUFFER_COUNT / 2; i++) {
+		for (j = 0; j < BUFFER_SIZE; j++) {
+			writebuf[j] = i * 2 * j;
+		}
+		len = write(fh, writebuf, sizeof(writebuf));
+		if (len != sizeof(writebuf)) {
+			err(1, "write failed");
+		}
+
+    // 23 Mar 2012 : GWA : Use lseek() to skip the odd guys.
+	
+    target = (i + 1) * 2 * sizeof(writebuf);
+    pos = lseek(fh, sizeof(writebuf), SEEK_END);
+    if (pos != target) {
+      err(1, "(even) lseek failed: %llu != %llu", pos, target);
+    }
+  }
+	
+  target = 0;
+  pos = lseek(fh, target, SEEK_SET);
+  if (pos != target) {
+    err(1, "(reset) lseek failed: %llu != %llu", pos, target);
+  }
+    
+  // 23 Mar 2012 : GWA : Do the odd-numbered writes. Test write() and
+  // lseek(SEEK_CUR).
+  
+  for (i = 0; i < BUFFER_COUNT / 2; i++) {
+    
+    // 23 Mar 2012 : GWA : Use lseek() to skip the even guys.
+    
+    target = ((i * 2) + 1) * sizeof(writebuf);
+    pos = lseek(fh, sizeof(writebuf), SEEK_CUR);
+    if (pos != target) {
+      err(1, "(odd) lseek failed: %llu != %llu", pos, target);
+    }
+    
+    for (j = 0; j < BUFFER_SIZE; j++) {
+			writebuf[j] = ((i * 2) + 1) * j;
+		}
+		len = write(fh, writebuf, sizeof(writebuf));
+		if (len != sizeof(writebuf)) {
+			err(1, "write failed");
+		}
+  }
+  
+	// 23 Mar 2012 : GWA : Read the test data back and make sure what we wrote
+	// ended up where we wrote it. Tests read() and lseek(SEEK_SET).
+	
+	printf("Verifying write.\n");
+
+	for (i = BUFFER_COUNT - 1; i >= 0; i--) {
+    target = i * sizeof(writebuf);
+		pos = lseek(fh, target, SEEK_SET);
+    if (pos != target) {
+      err(1, "(verify) lseek failed: %llu != %llu", pos, target);
+    }
+		len = read(fh, readbuf, sizeof(readbuf));
+		if (len != sizeof(readbuf)) {
+			err(1, "read failed");
+		}
+		for (j = BUFFER_SIZE - 1; j >= 0; j--) {
+			if (readbuf[j] != i * j) {
+				err(1, "read mismatch: pos=%llu, readbuf[j]=%d, i*j=%d, i=%d, j=%d", pos, readbuf[j], i * j, i, j);
+			}
+		}
+	}
+
+	// 23 Mar 2012 : GWA : Close the file.
+	
+	printf("Closing %s\n", filename);
+	close(fh);
+	
+	// 23 Mar 2012 : GWA : Make sure the file is actually closed.
+
+	pos = lseek(fh, (off_t) 0, SEEK_SET);
+	if (pos == 0) {
+		err(1, "seek after close succeeded");
+	}
+		
+	// 23 Mar 2012 : GWA : FIXME : Spin until exit() works.
+	
+	printf("Spinning in case exit() doesn't work.\n");
+	while (1) {};
+
+	return 0;
+}
